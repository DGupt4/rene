import base64
import os
import re
from datetime import UTC, datetime
from pathlib import Path

import httpx

from state import AgentState


def _slugify(value: str) -> str:
  slug = re.sub(r"[^a-zA-Z0-9]+", "-", value.strip().lower()).strip("-")
  return slug[:48] or "descartes-repro"


def _build_repo_name(state: AgentState) -> str:
  methodology = state["parsed_sections"].get("methodology") or ""
  title_hint = methodology.splitlines()[0][:80] if methodology else "paper-repro"
  base = _slugify(title_hint)
  stamp = datetime.now(UTC).strftime("%Y%m%d-%H%M%S")
  return f"{base}-{stamp}"


def _list_files(repo_dir: Path) -> list[Path]:
  files: list[Path] = []
  for path in repo_dir.rglob("*"):
    if path.is_file() and "__pycache__" not in path.parts:
      files.append(path)
  return files


def github_publisher_agent(state: AgentState) -> AgentState:
  token = os.environ.get("GITHUB_TOKEN", "").strip()
  owner = os.environ.get("GITHUB_OWNER", "").strip()
  private = os.environ.get("GITHUB_PRIVATE_REPOS", "true").strip().lower() != "false"
  output_repo_path = state.get("output_repo_path", "")

  if not token:
    print("[Publisher] Skipping publish — GITHUB_TOKEN not set")
    return {
      **state,
      "published": False,
      "github_publish_error": "GITHUB_TOKEN is not configured",
      "status": "publish skipped",
    }
  if not output_repo_path:
    print("[Publisher] Skipping publish — no output repo path")
    return {
      **state,
      "published": False,
      "github_publish_error": "No generated output repository path found",
      "status": "publish skipped",
    }

  repo_dir = Path(output_repo_path)
  if not repo_dir.exists():
    print(f"[Publisher] Skipping publish — output path missing: {repo_dir}")
    return {
      **state,
      "published": False,
      "github_publish_error": f"Output path does not exist: {repo_dir}",
      "status": "publish skipped",
    }

  repo_name = _build_repo_name(state)
  print(f"[Publisher] Creating GitHub repo: {repo_name}")

  headers = {
    "Authorization": f"Bearer {token}",
    "Accept": "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
  }

  with httpx.Client(timeout=30) as client:
    user_resp = client.get("https://api.github.com/user", headers=headers)
    if user_resp.status_code >= 400:
      return {
        **state,
        "published": False,
        "github_publish_error": f"Failed to verify GitHub token: {user_resp.text}",
        "status": "publish failed",
      }
    authed_login = user_resp.json().get("login", "")
    target_owner = owner or authed_login

    if target_owner == authed_login:
      create_url = "https://api.github.com/user/repos"
    else:
      create_url = f"https://api.github.com/orgs/{target_owner}/repos"

    create_resp = client.post(
      create_url,
      headers=headers,
      json={
        "name": repo_name,
        "private": private,
        "description": "Generated by Descartes paper-to-repro pipeline",
        "auto_init": False,
      },
    )
    if create_resp.status_code >= 400:
      return {
        **state,
        "published": False,
        "github_publish_error": f"Failed to create GitHub repo: {create_resp.text}",
        "status": "publish failed",
      }

    repo_meta = create_resp.json()
    full_name = repo_meta["full_name"]
    html_url = repo_meta["html_url"]

    files = _list_files(repo_dir)
    print(f"[Publisher] Uploading {len(files)} files to {full_name}")
    for file_path in files:
      rel = file_path.relative_to(repo_dir).as_posix()
      content_b64 = base64.b64encode(file_path.read_bytes()).decode()
      put_resp = client.put(
        f"https://api.github.com/repos/{full_name}/contents/{rel}",
        headers=headers,
        json={
          "message": f"Add {rel}",
          "content": content_b64,
          "branch": "main",
        },
      )
      if put_resp.status_code >= 400:
        return {
          **state,
          "published": False,
          "github_repo_name": repo_name,
          "github_publish_error": f"Failed uploading {rel}: {put_resp.text}",
          "status": "publish failed",
        }

  print(f"[Publisher] Done — {html_url}")
  return {
    **state,
    "published": True,
    "github_repo_name": repo_name,
    "github_repo_url": html_url,
    "github_publish_error": "",
    "status": "published",
  }
